using System;
using MicrosoftResearch.Infer;
using MicrosoftResearch.Infer.Distributions;
using MicrosoftResearch.Infer.Collections;
using MicrosoftResearch.Infer.Factors;

namespace MicrosoftResearch.Infer.Models.User
{
	/// <summary>
	/// Class for performing inference in model 'Model' using algorithm 'ExpectationPropagation'.
	/// </summary>
	/// <remarks>
	/// The easiest way to use this class is to wrap an instance in a CompiledAlgorithm object and use
	/// the methods on CompiledAlgorithm to set parameters and execute inference.
	/// 
	/// If you instead wish to use this class directly, you must perform the following steps:
	/// 1) Create an instance of the class
	/// 2) Set the value of any externally-set fields e.g. data, priors
	/// 3) Call the Reset() method
	/// 4) Call the Initialise() method once
	/// 5) Call the Update() method multiple times  - each call performs one iteration of inference
	/// 6) Use the XXXMarginal() methods to retrieve posterior marginals for different variables.
	/// 
	/// Generated by Infer.NET 2.3 beta 4 at 10:53 PM on Saturday, April 26, 2014.
	/// </remarks>
	public class Model0_EP : IIterativeProcess
	{
		#region Fields
		// The externally-specified value of 'bothHeads'
		public bool bothHeads;
		// Messages from uses of 'firstCoin'
		public Bernoulli[] firstCoin_uses_B;
		// The constant 'vBernoulli0'
		public Bernoulli vBernoulli0;
		// Message from definition of 'firstCoin'
		public Bernoulli firstCoin_F;
		// Messages from uses of 'secondCoin'
		public Bernoulli[] secondCoin_uses_B;
		// The constant 'vBernoulli1'
		public Bernoulli vBernoulli1;
		// Message from definition of 'secondCoin'
		public Bernoulli secondCoin_F;
		// Messages to uses of 'secondCoin'
		public Bernoulli[] secondCoin_uses_F;
		// Messages to uses of 'firstCoin'
		public Bernoulli[] firstCoin_uses_F;
		// Message to marginal of 'firstCoin'
		public Bernoulli firstCoin_marginal_B;
		// Message to marginal of 'secondCoin'
		public Bernoulli secondCoin_marginal_B;
		#endregion

		#region Methods
		/// <summary>
		/// Configures constant values that will not change during the lifetime of the class.
		/// </summary>
		/// <remarks>
		/// This method should be called once only after the class is instantiated.  In future, it will likely become
		/// the class constructor.
		/// </remarks>
		public void Reset()
		{
			// Create array for 'firstCoin_uses' backwards messages.
			this.firstCoin_uses_B = new Bernoulli[1];
			this.vBernoulli0 = new Bernoulli(0.5);
			this.firstCoin_F = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli0);
			// Message to 'firstCoin' from Random factor
			this.firstCoin_F = UnaryOp<bool>.RandomAverageConditional<Bernoulli>(this.vBernoulli0);
			// Create array for 'secondCoin_uses' backwards messages.
			this.secondCoin_uses_B = new Bernoulli[1];
			this.vBernoulli1 = new Bernoulli(0.5);
			this.secondCoin_F = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli1);
			// Message to 'secondCoin' from Random factor
			this.secondCoin_F = UnaryOp<bool>.RandomAverageConditional<Bernoulli>(this.vBernoulli1);
			// Create array for 'secondCoin_uses' forwards messages.
			this.secondCoin_uses_F = new Bernoulli[1];
			// Create array for 'firstCoin_uses' forwards messages.
			this.firstCoin_uses_F = new Bernoulli[1];
		}

		/// <summary>
		/// Creates message arrays and initialises their values ready for inference to be performed.
		/// </summary>
		/// <remarks>
		/// This method should be called once each time inference is performed. Since the initialisation
		/// procedure normally dependson external values such as priors and array sizes, all external
		/// values must be set before calling this method.
		/// 
		/// As well as initialising message arrays, this method also performs any message passing that
		/// the scheduler determines need only be carried out once.
		/// </remarks>
		public void Initialise()
		{
			this.firstCoin_marginal_B = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli0);
			for(int _ind0 = 0; _ind0<1; _ind0++)
			{
				this.firstCoin_uses_B[_ind0] = ArrayHelper.MakeUniform<Bernoulli>(this.vBernoulli0);
			}
			this.secondCoin_marginal_B = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli1);
			for(int _ind0 = 0; _ind0<1; _ind0++)
			{
				this.secondCoin_uses_B[_ind0] = ArrayHelper.MakeUniform<Bernoulli>(this.vBernoulli1);
			}
			for(int _ind0 = 0; _ind0<1; _ind0++)
			{
				this.secondCoin_uses_F[_ind0] = ArrayHelper.MakeUniform<Bernoulli>(this.vBernoulli1);
			}
			// Message to 'secondCoin_uses' from UsesEqualDef factor
			this.secondCoin_uses_F[0] = UsesEqualDefOp.UsesAverageConditional<Bernoulli>(this.secondCoin_uses_B, this.secondCoin_F, 0, this.secondCoin_uses_F[0]);
			// Message to 'firstCoin_uses' from And factor
			this.firstCoin_uses_B[0] = BooleanAndOp.AAverageConditional(this.bothHeads, this.secondCoin_uses_F[0]);
			// Message to 'firstCoin_marginal' from UsesEqualDef factor
			this.firstCoin_marginal_B = UsesEqualDefOp.MarginalAverageConditional<Bernoulli>(this.firstCoin_uses_B, this.firstCoin_F, this.firstCoin_marginal_B);
			for(int _ind0 = 0; _ind0<1; _ind0++)
			{
				this.firstCoin_uses_F[_ind0] = ArrayHelper.MakeUniform<Bernoulli>(this.vBernoulli0);
			}
			// Message to 'firstCoin_uses' from UsesEqualDef factor
			this.firstCoin_uses_F[0] = UsesEqualDefOp.UsesAverageConditional<Bernoulli>(this.firstCoin_uses_B, this.firstCoin_F, 0, this.firstCoin_uses_F[0]);
			// Message to 'secondCoin_uses' from And factor
			this.secondCoin_uses_B[0] = BooleanAndOp.BAverageConditional(this.bothHeads, this.firstCoin_uses_F[0]);
			// Message to 'secondCoin_marginal' from UsesEqualDef factor
			this.secondCoin_marginal_B = UsesEqualDefOp.MarginalAverageConditional<Bernoulli>(this.secondCoin_uses_B, this.secondCoin_F, this.secondCoin_marginal_B);
		}

		/// <summary>
		/// Performs one iteration of inference.
		/// </summary>
		/// <remarks>
		/// This method should be called multiple times, after calling Initialise(), in order to perform
		/// multiple iterations of message passing.  You can call methods to retrieve posterior marginals
		/// at any time - the returned marginal will be the estimated marginal given the current state of
		/// the message passing algorithm.  This can be useful for monitoring convergence of the algorithm.
		/// 
		/// Where the scheduler has determined inference can be performed without iteration, this method
		/// does nothing.
		/// </remarks>
		public void Update()
		{
		}

		/// <summary>
		/// Returns the marginal distribution for 'firstCoin' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public Bernoulli FirstCoinMarginal()
		{
			return this.firstCoin_marginal_B;
		}

		/// <summary>
		/// Returns the marginal distribution for 'secondCoin' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public Bernoulli SecondCoinMarginal()
		{
			return this.secondCoin_marginal_B;
		}

		#endregion

	}

}
